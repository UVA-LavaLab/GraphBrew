# AdaptiveOrder Performance Accounting (Phase 3)

Generated by agent recipe Phase 3 — stage-level profiling of Algorithm 14.

---

## Stage Breakdown

Timers were added to `GenerateAdaptiveMappingRecursiveStandalone()` in
`reorder_adaptive.h`, guarded by the existing `verbose` flag.

| Stage | Timer Variable | What It Covers |
|-------|---------------|----------------|
| Leiden Partitioning | `t_leiden` | `runGraphBrew<K>(g, gb_config)` — community detection |
| Global Features | `t_features` | `ComputeSampledDegreeFeatures(g, 10000, true)` — sampled degree stats |
| Small Communities | `t_small` | Hash-set construction + node collection for communities < threshold |
| Comm Features (sum) | `t_comm_features_total` | `ComputeCommunityFeaturesStandalone()` summed over all large communities |
| Comm Scoring (sum) | `t_comm_scoring_total` | `SelectBestReorderingForCommunity()` summed over all large communities |
| Comm Reorder (sum) | `t_comm_reorder_total` | `ReorderCommunitySubgraphStandalone()` summed over all large communities |
| Overhead (unaccounted) | computed | `total - all above` — dispatch logic, memory allocation |

---

## Empirical Results

### RMAT-16 (65,536 nodes, 909,646 edges)

| Stage | Time (s) | % of Total |
|-------|----------|-----------|
| Leiden Partitioning | 0.046 | 6.5% |
| Global Features | 0.136 | 19.3% |
| Small Communities | 0.472 | 66.9% |
| Comm Features (sum) | 0.013 | 1.8% |
| Comm Scoring (sum) | 0.012 | 1.7% |
| Comm Reorder (sum) | 0.021 | 3.0% |
| Overhead (unaccounted) | 0.007 | 1.0% |
| **Total** | **0.706** | **100%** |

- Large communities: 14
- Small-group nodes: 63,721 (97.2% of all nodes)

### RMAT-17 (131,071 nodes, 1,864,448 edges)

| Stage | Time (s) | % of Total |
|-------|----------|-----------|
| Leiden Partitioning | 0.061 | 2.9% |
| Global Features | 0.087 | 4.2% |
| Small Communities | 1.823 | 87.5% |
| Comm Features (sum) | 0.017 | 0.8% |
| Comm Scoring (sum) | 0.016 | 0.8% |
| Comm Reorder (sum) | 0.077 | 3.7% |
| Overhead (unaccounted) | 0.003 | 0.1% |
| **Total** | **2.084** | **100%** |

- Large communities: 19
- Small-group nodes: 127,654 (97.4% of all nodes)

---

## Key Finding: Small-Community Bottleneck

The dominant cost (67–88% of total time) is the **small-community grouping** stage.
This stage iterates over every community smaller than 200 nodes, inserts its member
nodes into a hash set (`community_nodes_set`), and collects them into a dense vector.

For RMAT graphs, Leiden typically produces:
- ~14–19 large communities (≥200 nodes) processed individually
- ~15,000–30,000+ tiny communities (1–50 nodes each) grouped together
- 97%+ of all nodes end up in the small-community group

The per-community `unordered_set` insertion dominates because:
1. Many small hash-set allocations (one per tiny community)
2. Random-access into the membership vector for each community
3. O(N) iteration over all communities, not just large ones

### Optimization Opportunities

1. **Pre-partition by size**: Sort communities by size first, early-exit when
   size drops below threshold (avoids scanning all communities).
2. **Bitmap instead of hash-set**: Use a `vector<bool>` for `community_nodes_set`
   since node IDs are dense integers in [0, N).
3. **Invert the loop**: Instead of iterating communities → nodes, iterate nodes
   once and bin them by community size.

These are noted here for Phase 6 consideration (Tier 0 internal optimization).

---

## Output Format

When `verbose=true` (default for depth==0), the breakdown prints after the
community processing loop:

```
=== AdaptiveOrder Stage Breakdown ===
  Leiden Partitioning: X.XXXXX
  Global Features:     X.XXXXX
  Small Communities:   X.XXXXX
  Comm Features (sum): X.XXXXX
  Comm Scoring (sum):  X.XXXXX
  Comm Reorder (sum):  X.XXXXX
  Overhead (unaccounted): X.XXXXX
  Total:               X.XXXXX
Large communities: NN, Small-group nodes: NNNNN
```
