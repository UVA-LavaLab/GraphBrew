# AdaptiveOrder Model Quality Evaluation (Phase 4)

Generated by agent recipe Phase 4 — oracle comparison, accuracy, and regret.

---

## Methodology

### Oracle Definition
- **Whole-graph oracle**: For each `(graph, benchmark)` pair, the oracle is the
  single algorithm that produces the lowest kernel execution time among all
  candidate algorithms (IDs 0–11). This is the "best you could do" if you
  knew the optimal algorithm upfront.
- **AdaptiveOrder selection**: What Algorithm 14 actually chooses per community.
  The "dominant selection" is the algorithm applied to the most nodes (usually
  the small-community merged group, which contains 90%+ of all nodes).

### Data Collection
- Script: `scripts/lib/oracle.py`
- Live experiment on 2 graphs × 2 benchmarks × 12 candidate algorithms + AdaptiveOrder
- 3 trials per configuration for timing stability

---

## Results Summary

### Tested: soc-Slashdot0902 (82K nodes) and web-Google (876K nodes)

| Graph | Benchmark | Oracle | Oracle Time | Adaptive | Adaptive Time | Regret | Rank |
|-------|-----------|--------|-------------|----------|---------------|--------|------|
| soc-Slashdot0902 | bfs | GORDER | 0.31ms | HUBCLUSTERDBG | 6.97ms | 2148% | 5/11 |
| soc-Slashdot0902 | pr | RABBITORDER_csr | 13.9ms | HUBCLUSTERDBG | 103.6ms | 646% | 9/11 |
| web-Google | bfs | RABBITORDER_csr | 0.63ms | HUBSORTDBG | 22.1ms | 3408% | 6/11 |
| web-Google | pr | RABBITORDER_csr | 23.7ms | HUBSORTDBG | 47.5ms | 100% | 3/11 |

### Overall Metrics
- **Selection accuracy**: 0% (adaptive never picks the oracle)
- **Top-3 rate**: 25% (1/4 cases in top-3)
- **Mean regret**: 1576%
- **Median regret**: 2148%

---

## Root Cause Analysis

### 1. Small-Community Dominance

Leiden partitioning splits graphs into many tiny communities:

| Graph | Total Communities | Large (≥200 nodes) | Small-Group Nodes | % of Graph |
|-------|-------------------|---------------------|-------------------|------------|
| soc-Slashdot0902 | 30,583 | 10 | 79,266 | 96.4% |
| web-Google | ~50,000+ | ~20 | ~860,000+ | ~98%+ |

**Impact**: 96–98% of nodes are reordered using the perceptron's selection
for the merged small-community group. This selection is made based on
the *aggregate* features of many tiny communities, which bear little
resemblance to any single graph type. The perceptron picks
HUBCLUSTERDBG/HUBSORTDBG (simple hub-aware sorts) when the graph would
benefit from RABBITORDER (hierarchical community-based reordering).

### 2. Architecture Mismatch

AdaptiveOrder splits the graph → reorders each piece → stitches together.
But the oracle algorithms (RABBITORDER, GORDER) process the **entire graph**
as a unit, leveraging global structure that per-community reordering cannot.

| Approach | Sees Global Structure | Locality Quality | Overhead |
|----------|----------------------|------------------|----------|
| AdaptiveOrder | No (per-community) | Moderate | High (Leiden + stitching) |
| RABBITORDER | Yes (whole graph) | High | Low (single pass) |
| GORDER | Yes (whole graph) | Highest | High (O(N²)-ish) |

### 3. BFS Regret Inflation

BFS times are in the sub-millisecond range (~0.3–0.6ms for oracle). At this
scale, measurement noise and constant overhead (stitching, hash map lookups)
dominate. The 2000–3400% regret for BFS is partly noise, partly real overhead.

PR regret (100–646%) is more meaningful and still very high.

---

## Confusion Matrix

| Oracle → | Adaptive picks HUBCLUSTERDBG | Adaptive picks HUBSORTDBG |
|----------|:---:|:---:|
| RABBITORDER_csr | 1 | 2 |
| GORDER | 1 | 0 |

The model never selects RABBITORDER or GORDER as candidates. This suggests
the perceptron weights for these algorithms are systematically lower than
HUBCLUSTERDBG/HUBSORTDBG across all feature combinations seen here.

---

## Interpretation for Improvements

### Priority Fixes (Phase 6)

1. **Packing factor short-circuit** (SOTA Idea 1.2): For graphs where
   ORIGINAL is competitive, skip reordering entirely. Currently, even when
   ORIGINAL is the oracle, AdaptiveOrder still runs Leiden + full pipeline.

2. **Cost model** (SOTA Idea 1.1): The reorder overhead of AdaptiveOrder
   itself (Leiden + stitching) exceeds the benefit. A `net_benefit < 0 →
   return ORIGINAL` guard would prevent many worst cases.

3. **Weight retraining**: The current perceptron weights appear biased toward
   simple hub-sort algorithms. Retraining with proper cross-validation on
   the current candidate pool may fix the systematic bias.

4. **Algorithm pool expansion**: AdaptiveOrder currently selects from
   algorithms 0–11 per community. Adding RABBITORDER-on-whole-graph as a
   "skip community decomposition" fast path would let the model choose the
   empirically best strategy.

### What This Means

The current AdaptiveOrder has the **correct architecture** (community-aware,
feature-driven selection) but **suboptimal weights and decision thresholds**.
The model needs:
- Better training data covering the actual candidate pool
- A cost-aware gate that skips the full pipeline when simpler approaches win
- More aggressive fallback to ORIGINAL or whole-graph algorithms

---

## Tool Reference

```bash
# Run oracle analysis on existing results
python3 scripts/graphbrew_experiment.py --oracle-analysis

# Or directly via module with full options
python3 -m scripts.lib.oracle --results-dir results/ --benchmarks pr bfs

# Run live experiment on specific graphs
python3 -m scripts.lib.oracle --run-experiment \
  --graphs results/graphs/soc-Slashdot0902/soc-Slashdot0902.sg \
  --benchmarks pr bfs --trials 3

# JSON output for programmatic consumption
python3 -m scripts.lib.oracle --results-dir results/ --json
```
